# ROP - Return Oriented Programing

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Basic Information**

**Return-Oriented Programming (ROP)** is an advanced exploitation technique used to circumvent security measures like **No-Execute (NX)** or **Data Execution Prevention (DEP)**. Instead of injecting and executing shellcode, an attacker leverages pieces of code already present in the binary or in loaded libraries, known as **"gadgets"**. Each gadget typically ends with a `ret` instruction and performs a small operation, such as moving data between registers or performing arithmetic operations. By chaining these gadgets together, an attacker can construct a payload to perform arbitrary operations, effectively bypassing NX/DEP protections.

### Calling Conventions

Understanding **calling conventions** is crucial for constructing effective ROP chains, especially when calling functions or manipulating data:

**x86 (32-bit)**

* **cdecl**: The caller cleans the stack. Function arguments are pushed onto the stack in reverse order (right-to-left). **Arguments are pushed onto the stack from right to left.**
* **stdcall**: Similar to cdecl, but the callee is responsible for cleaning the stack.

**x64 (64-bit)**

* Uses the **System V AMD64 ABI** calling convention on Unix-like systems, where the **first six integer or pointer arguments are passed in the registers `RDI`, `RSI`, `RDX`, `RCX`, `R8`, and `R9`**. Additional arguments are passed on the stack. The return value is placed in `RAX`.
* **Windows x64** calling convention uses `RCX`, `RDX`, `R8`, and `R9` for the first four integer or pointer arguments, with additional arguments passed on the stack. The return value is placed in `RAX`.
* **Registers**: 64-bit registers include `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP`, and `R8` to `R15`.

{% hint style="danger" %}
From those calling conventions it's possible to observe that in **32 bits the arguments** to functions are **passed through the stack** while in **x64** they are **placed in specific registers**.
{% endhint %}

### How ROP Works

1. **Control Flow Hijacking**: First, an attacker needs to hijack the control flow of a program, typically by exploiting a buffer overflow to overwrite a saved return address on the stack.
2. **Gadget Chaining**: The attacker then carefully selects and chains gadgets to perform the desired actions. This could involve setting up arguments for a function call, calling the function (e.g., `system("/bin/sh")`), and handling any necessary cleanup or additional operations.
3. **Payload Execution**: When the vulnerable function returns, instead of returning to a legitimate location, it starts executing the chain of gadgets.

### ROP Chain in x86

Let's consider a hypothetical scenario where we want to call `system("/bin/sh")` using ROP in a 32-bit binary:

1. **Find Gadgets**: Suppose we have found the following gadgets in the binary or loaded libraries:
   * `pop eax; ret`: Pops the top of the stack into `EAX` and returns.
   * `pop ebx; ret`: Pops the top of the stack into `EAX` and returns.
   * `mov [ebx], eax; ret`: Moves the value in `EAX` to the location pointed to by `EBX`.
   * The address of `system`.
2. **Prepare the Chain**: We need to prepare a stack that looks like this:
   * The address of the gadget that sets `EBX`.
   * The address of the `pop eax; ret` gadget.
   * The address of the string `"/bin/sh"` in memory (or where we plan to write it).
   * The address of the `mov [ebx], eax; ret` gadget, to move `"/bin/sh"` into the location pointed by `EBX`.
   * The address of the `system` function, with `EBX` pointing to our string.
3. **Execution**: When the vulnerable function returns, it starts executing our gadget chain, eventually calling `system("/bin/sh")`, and popping a shell.

### ROP in x64

Consider a hypothetical scenario where you want to call `execve("/bin/sh", NULL, NULL)` on an x64 system using the System V AMD64 ABI:

1. **Finding Gadgets**: You would first need to find gadgets that allow you to control the `RDI`, `RSI`, and `RDX` registers, as these will hold the arguments to `execve`.
2. **Chain Construction**:
   * **Set `RDI` to point to the string `"/bin/sh"`**: This is typically done with a `pop RDI; ret` gadget followed by the address of the string (which may need to be placed in the payload or found in memory).
   * **Zero out `RSI` and `RDX`**: Since the second and third arguments to `execve` are `NULL`, you need gadgets to zero these registers, like `xor RSI, RSI; ret` and `xor RDX, RDX; ret`.
   * **Call `execve`**: Finally, a gadget that jumps to `execve` (or indirectly calls it) is required.
3. **Payload Execution**: After constructing and sending this payload to a vulnerable application, the ROP chain executes, spawning a shell.

Since x64 uses registers for the first few arguments, it often requires fewer gadgets than x86 for simple function calls, but finding and chaining the right gadgets can be more complex due to the increased number of registers and the larger address space. The increased number of registers and the larger address space in **x64** architecture provide both opportunities and challenges for exploit development, especially in the context of Return-Oriented Programming (ROP).

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** üí¨ [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
